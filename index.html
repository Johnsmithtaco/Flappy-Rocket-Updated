<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Rocket Runner ‚Äì Asteroid Edition</title>
<meta name="description" content="Flappy‚Äëstyle rocket game with asteroid fields, sprite animations, and retro chiptune. Pure HTML5 Canvas."/>
<style>
  :root {
    --ui: #e9f1ff;
    --ui-dim: #9fb4d9;
    --accent: #7fd1ff;
    --danger: #ff5c7a;
    --shadow: rgba(0,0,0,0.35);
  }
  html, body { margin:0; padding:0; height:100%; background:#060a14; overflow:hidden;
    font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
    color:var(--ui); -webkit-user-select:none; user-select:none; touch-action: manipulation; }
  #wrap { position:relative; width:100vw; height:100vh; }
  canvas { display:block; width:100%; height:100%; image-rendering: pixelated; }
  .hud { position:absolute; left:0; right:0; top:0; padding:12px 16px;
    display:flex; justify-content:space-between; align-items:center; pointer-events:none; text-shadow:0 2px 6px var(--shadow); }
  .score { font-weight:800; font-size: clamp(20px, 4.2vh, 38px); letter-spacing:1px; }
  .best { font-size: clamp(12px, 2.2vh, 16px); opacity:.8; }
  .btnbar { position:absolute; left:0; right:0; bottom:0; padding:10px; display:flex; justify-content:center; gap:10px; }
  .btn {
    pointer-events:auto; cursor:pointer; border:none; border-radius:10px; padding:10px 14px; font-weight:700;
    background:linear-gradient(180deg,#1a2440,#0f162a); color:var(--ui); box-shadow:0 6px 18px var(--shadow);
    outline:none; transition:transform .06s ease;
  }
  .btn:active { transform:translateY(1px) scale(.99); }
  .overlay {
    position:absolute; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center;
    background: radial-gradient(60% 60% at 50% 40%, rgba(12,16,34,.55), rgba(6,10,20,.9));
    text-align:center; gap:18px; padding:24px; backdrop-filter: blur(2px);
  }
  .title { font-weight:900; font-size: clamp(28px, 6.8vh, 64px); letter-spacing:1px; text-shadow:0 10px 30px var(--shadow); }
  .subtitle { color:var(--ui-dim); font-size: clamp(14px, 2.6vh, 18px); }
  .kbd { display:inline-block; padding:.2em .45em; border-radius:6px; background:#0a1022; border:1px solid #1b2750; color:#cfe2ff;
    box-shadow: inset 0 1px 0 rgba(255,255,255,.05); }
  .small { font-size:.9em; color:#a9bbdf; }
  .danger { color:var(--danger); }
  .chip { pointer-events:auto; border:none; border-radius:999px; padding:8px 12px; font-weight:700; background:#0a132a; color:#cfe2ff; }
  .top-right { position:absolute; right:10px; top:52px; display:flex; gap:8px; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game"></canvas>

  <div class="hud">
    <div class="score" id="score">0</div>
    <div class="best" id="best">BEST: 0</div>
  </div>

  <div class="top-right">
    <button class="chip" id="muteBtn" aria-label="Toggle sound">üîä</button>
    <button class="chip" id="pauseBtn" aria-label="Pause/Resume">‚èØ</button>
    <button class="chip" id="restartBtn" aria-label="Restart">üîÑ</button>
  </div>

  <div class="overlay" id="startOverlay" role="dialog" aria-live="polite">
    <div class="title">ROCKET RUNNER</div>
    <div class="subtitle">Tap / Click / <span class="kbd">Space</span> / <span class="kbd">‚Üë</span> to thrust.<br/>Slip through the asteroid gaps. Don‚Äôt crash.</div>
    <div class="small">Asteroid fields, sprite animations, and a tiny chiptune synth ‚Äî no assets required.</div>
    <button class="btn" id="startBtn">üöÄ Launch</button>
  </div>

  <div class="overlay" id="gameOverOverlay" style="display:none;">
    <div class="title danger">MISSION FAILED</div>
    <div class="subtitle">Score: <span id="finalScore">0</span> &nbsp;‚Ä¢&nbsp; Best: <span id="finalBest">0</span></div>
    <div class="small">Tip: short, rhythmic taps beat long presses.</div>
    <button class="btn" id="againBtn">‚ñ∂Ô∏è Try Again</button>
  </div>
</div>

<script>
(() => {
  /* ===== Helpers ===== */
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a,b)=>Math.random()*(b-a)+a;
  const lerp = (a,b,t)=>a+(b-a)*t;

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
  const sizeCanvas = () => {
    const w = window.innerWidth, h = window.innerHeight;
    canvas.width = Math.floor(w * DPR);
    canvas.height = Math.floor(h * DPR);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.imageSmoothingEnabled = false;
  };
  sizeCanvas();
  window.addEventListener('resize', ()=>{DPR=Math.max(1, Math.min(window.devicePixelRatio||1,2)); sizeCanvas();});

  /* ===== Game State ===== */
  const state = { active:false, activeTime:0, 
    running:false, paused:false, over:false, started:false,
    t:0, dt:0, last:0, score:0,
    best: parseInt(localStorage.getItem('rocket_runner_best')||'0',10),
    shake:0, muted:false,
  };

  /* ===== UI elements ===== */
  const startOverlay = document.getElementById('startOverlay');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const startBtn = document.getElementById('startBtn');
  const againBtn = document.getElementById('againBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const muteBtn = document.getElementById('muteBtn');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const finalScore = document.getElementById('finalScore');
  const finalBest = document.getElementById('finalBest');
  bestEl.textContent = 'BEST: ' + state.best;

  /* ===== Controls ===== */
  let thrustHeld = false;
  const press = (e)=>{ thrustHeld = true; e && e.preventDefault(); if(state.started && !state.active && !state.over){ state.active = true; if (!state.muted) startMusic(); rocket.vy = -metrics().maxVel*0.42; } };
  const release = (e)=>{ thrustHeld = false; e && e.preventDefault(); };

  window.addEventListener('keydown', e=>{
    if (e.code==='Space' || e.code==='ArrowUp') { press(e); if(!state.started) beginGame(); }
    if (e.code==='KeyP') togglePause();
    if (e.code==='KeyM') toggleMute();
  }, {passive:false});
  window.addEventListener('keyup', e=>{
    if (e.code==='Space' || e.code==='ArrowUp') release(e);
  }, {passive:false});
  canvas.addEventListener('pointerdown', e=>{ press(e); if(!state.started) beginGame(); }, {passive:false});
  window.addEventListener('pointerup', release, {passive:false});
  window.addEventListener('blur', ()=>{ if (state.running && !state.over) togglePause(true); });

  startBtn.onclick = ()=>beginGame();
  againBtn.onclick = ()=>reset(true);
  pauseBtn.onclick = ()=>togglePause();
  restartBtn.onclick = ()=>reset(true);
  muteBtn.onclick = ()=>toggleMute();

  function togglePause(forcePause=false){
    if (!state.started || state.over) return;
    state.paused = forcePause ? true : !state.paused;
  }
  function toggleMute(){
    state.muted = !state.muted;
    if (state.muted) { stopMusic(); muteBtn.textContent='üîá'; }
    else { startMusic(); muteBtn.textContent='üîä'; }
  }

  /* ===== World Metrics ===== */
  function metrics(){
    const W = canvas.width, H = canvas.height;
    const unit = Math.min(W,H)/100;
    return {
      W,H, unit,
      gravity: 0.18*unit,
      thrust: 0.38*unit,
      maxVel: 3.2*unit,
      gap: clamp(H*0.22, 16*unit, 28*unit),
      clusterW: clamp(20*unit, 120, 28*unit),
      spacing: clamp(W*0.48, 70*unit, 120*unit),
      rocketSize: clamp(7.5*unit, 50, 16*unit),
      scroll: clamp(2.0*unit, 2.2*unit, 3.2*unit)
    };
  }

  
  /* ===== Speed scaling ===== */
  function speedMultiplier(){
    // Very gentle ramp: ~+20% by ~3 minutes of continuous play, capped at +60%
    const t = state.activeTime; // ms since first tap
    const mult = 1 + Math.min(0.60, t * 0.000003); // 0.000003 per ms = 0.18 per minute
    return mult;
  }
/* ===== Background Parallax ===== */
  const bg = {
    layers: [],
    reset(){
      this.layers = [];
      const {W,H} = metrics();
      const blobs = Array.from({length:4}, ()=>({x:rand(0,W), y:rand(0,H), r:rand(H*0.25, H*0.5), hue:rand(200, 280), alpha:0.06}));
      const mkStars = (n, speed, sMin, sMax)=>Array.from({length:n}, ()=>({x:rand(0,W), y:rand(0,H), z:speed, s:rand(sMin,sMax), tw:rand(0,Math.PI*2)}));
      this.layers.push({type:'nebula', blobs});
      this.layers.push({type:'stars', stars: mkStars(140, .25, 0.8, 1.5)});
      this.layers.push({type:'stars', stars: mkStars(90, .5, 1.0, 2.0)});
      this.layers.push({type:'stars', stars: mkStars(60, 1.0, 1.5, 2.5)});
    },
    update(dt){
      const {W,H, scroll} = metrics();
      const mult = state.active ? speedMultiplier() : 0;
      for (const L of this.layers){
        if (L.type!=='stars') continue;
        for (const s of L.stars){
          s.x -= scroll * mult * s.z * dt * 0.06;
          if (s.x < -4) { s.x = W + rand(0,50); s.y = rand(0,H); }
          s.tw += dt*0.006;
        }
      }
    },
    draw(){
      const {W,H} = metrics();
      const g = ctx.createLinearGradient(0,0,0,H);
      g.addColorStop(0,'#0b1024'); g.addColorStop(1,'#050814');
      ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

      for (const bgl of this.layers){
        if (bgl.type==='nebula'){
          for (const b of bgl.blobs){
            const grad = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.r);
            grad.addColorStop(0, `hsla(${b.hue},70%,70%,${b.alpha})`);
            grad.addColorStop(1, `hsla(${b.hue},70%,30%,0)`);
            ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
          }
        } else if (bgl.type==='stars'){
          for (const s of bgl.stars){
            const tw = (Math.sin(s.tw)*0.5+0.5)*0.7+0.3;
            ctx.fillStyle = `rgba(255,255,${200+55*tw},${0.6+0.4*tw})`;
            ctx.fillRect(Math.floor(s.x), Math.floor(s.y), s.s, s.s);
          }
        }
      }
      // Distant planet
      const planetR = Math.min(W,H)*0.16;
      const px = W*0.72, py = H*0.28;
      const pg = ctx.createRadialGradient(px-planetR*0.3, py-planetR*0.3, planetR*0.1, px, py, planetR);
      pg.addColorStop(0,'#2b7cff'); pg.addColorStop(1,'#0d1a42');
      ctx.fillStyle = pg; ctx.beginPath(); ctx.arc(px,py,planetR,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(255,255,255,0.05)';
      for(let i=0;i<6;i++){ ctx.beginPath(); ctx.arc(px,py, planetR*(0.4+i*0.1), 0, Math.PI*2); ctx.stroke(); }
    }
  };
  bg.reset();

  /* ===== Procedural Sprite Sheets ===== */
  // We'll build two sprite sheets: rocket flame flicker, and rotating debris.
  const sprites = {
    flameFrames: [], // canvas frames
    debrisFrames: [],
    make(){
      const m = metrics();
      // Flame frames
      const fCount = 6;
      this.flameFrames = [];
      for (let i=0;i<fCount;i++){
        const c = document.createElement('canvas'); const s = Math.floor(m.rocketSize*0.9); c.width=c.height=s;
        const g = c.getContext('2d');
        for (let p=0;p<28;p++){
          const r = rand(s*0.06, s*0.22);
          const x = s*0.2 + rand(-s*0.06,s*0.06);
          const y = s*0.5 + rand(-s*0.08,s*0.08);
          const grd = g.createRadialGradient(x,y,0,x,y,r);
          const a = 0.35 + 0.12*Math.sin(i*0.8 + p*0.2);
          grd.addColorStop(0, `rgba(255,240,180,${a})`);
          grd.addColorStop(1, `rgba(255,140,40,0)`);
          g.fillStyle = grd; g.beginPath(); g.arc(x + p*0.2, y + (p%3-1)*0.5, r, 0, Math.PI*2); g.fill();
        }
        this.flameFrames.push(c);
      }
      // Debris frames (rock rotating)
      const dCount = 12;
      const size = Math.floor(m.clusterW*0.7);
      this.debrisFrames = [];
      for (let i=0;i<dCount;i++){
        const c = document.createElement('canvas'); c.width=c.height=size;
        const g = c.getContext('2d');
        g.translate(size/2, size/2);
        g.rotate((i/dCount)*Math.PI*2);
        drawRockShape(g, size*0.36, '#6f7a8a', '#3b4352');
        this.debrisFrames.push(c);
      }
      function drawRockShape(g, r, fill, stroke){
        g.beginPath();
        const pts = 10;
        for(let k=0;k<pts;k++){
          const ang = k/pts * Math.PI*2;
          const rad = r * (0.7 + Math.random()*0.6);
          const x = Math.cos(ang)*rad, y = Math.sin(ang)*rad;
          if (k===0) g.moveTo(x,y); else g.lineTo(x,y);
        }
        g.closePath();
        const grad = g.createLinearGradient(-r,-r,r,r);
        grad.addColorStop(0, '#8d98aa'); grad.addColorStop(0.5, fill); grad.addColorStop(1, '#505a6b');
        g.fillStyle = grad; g.fill();
        g.lineWidth = Math.max(1, r*0.08); g.strokeStyle = stroke; g.stroke();
        // pockmarks
        g.fillStyle = 'rgba(20,20,30,0.25)';
        for(let i=0;i<6;i++){
          g.beginPath(); g.arc(rand(-r*0.5,r*0.5), rand(-r*0.5,r*0.5), r*rand(0.06,0.12), 0, Math.PI*2); g.fill();
        }
      }
    }
  };
  sprites.make();
  window.addEventListener('resize', ()=>sprites.make());

  /* ===== Rocket ===== */
  const rocket = {
    x:0, y:0, vy:0, r:0, size:14, alive:true, invuln:0,
    flameI:0,
    reset(){
      const {W,H,rocketSize} = metrics();
      this.x = W*0.28; this.y = H*0.5; this.vy = 0; this.r = 0; this.size = rocketSize; this.alive = true; this.invuln = 0;
    },
    update(dt){
      const m = metrics();
      const g = m.gravity, th = m.thrust, maxV = m.maxVel;
      if (state.active) {
      this.vy += g*dt;
      if (thrustHeld) this.vy -= th*dt*1.4;
      this.vy = clamp(this.vy, -maxV, maxV);
      this.y += this.vy;
    }
      // rotation
      const targetR = state.active ? lerp(-0.35, 0.65, (this.vy+maxV)/(2*maxV)) : 0;
      this.r = lerp(this.r, targetR, 0.12);
      // bounds
      const {H} = m;
      if (state.active && (this.y < 0 || this.y > H)) this.crash();
      if (this.invuln>0) this.invuln -= dt*16;
      // flame anim
      this.flameI = (this.flameI + dt*(state.active?0.02:0.006)) % sprites.flameFrames.length;
    },
    draw(){
      const s = this.size;
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.r);

      // Body
      const bodyGrad = ctx.createLinearGradient(-s, -s, s, s);
      bodyGrad.addColorStop(0, '#c6d7ff');
      bodyGrad.addColorStop(0.5, '#eef4ff');
      bodyGrad.addColorStop(1, '#9eb8ff');
      ctx.fillStyle = bodyGrad;
      roundedRect(-s*0.6, -s*0.35, s*1.1, s*0.7, s*0.22, true);

      // Nose
      ctx.fillStyle = '#e3edff';
      ctx.beginPath();
      ctx.moveTo(s*0.55, 0);
      ctx.quadraticCurveTo(s*0.85, -s*0.25, s*0.9, 0);
      ctx.quadraticCurveTo(s*0.85, s*0.25, s*0.55, 0);
      ctx.closePath(); ctx.fill();

      // Window
      ctx.fillStyle = '#14254a'; roundedRect(-s*0.1, -s*0.18, s*0.38, s*0.36, s*0.12, true);
      const glare = ctx.createLinearGradient(-s*0.1, -s*0.18, s*0.28, s*0.18);
      glare.addColorStop(0, 'rgba(255,255,255,0.75)'); glare.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = glare; roundedRect(-s*0.08, -s*0.16, s*0.18, s*0.12, s*0.06, true);

      // Fins
      ctx.fillStyle = '#ff5c7a';
      roundedRect(-s*0.55, -s*0.05 - s*0.34, s*0.28, s*0.34, s*0.06, true);
      roundedRect(-s*0.55,  s*0.05,               s*0.28, s*0.34, s*0.06, true);

      // Nozzle
      ctx.fillStyle = '#394a7a';
      roundedRect(-s*0.7, -s*0.18, s*0.18, s*0.36, s*0.05, true);

      // Flame sprite
      const frame = sprites.flameFrames[Math.floor(this.flameI)];
      if (frame) {
        ctx.drawImage(frame, -s*0.9, -s*0.45, s*0.7, s*0.9);
      }

      ctx.restore();

      function roundedRect(x,y,w,h,r,fill){
        ctx.beginPath();
        ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r);
        ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r);
        if(fill){ ctx.fill(); } else { ctx.stroke(); }
      }
    },
    hitbox(){
      const r = this.size*0.48;
      return {x:this.x - r*0.8, y:this.y - r*0.6, w:r*1.4, h:r*1.2};
    },
    crash(){
      if (!this.alive) return;
      this.alive=false; state.over=true; state.running=false; state.shake=10;
      finalScore.textContent = state.score;
      state.best = Math.max(state.best, state.score);
      localStorage.setItem('rocket_runner_best', String(state.best));
      finalBest.textContent = state.best;
      thump();
      stopMusic();
      setTimeout(()=>{ gameOverOverlay.style.display='flex'; }, 160);
    }
  };

  /* ===== Asteroid Clusters (obstacles) ===== */
  // Each obstacle is a top and bottom cluster (belt) with a vertical gap.
  const field = {
    list: [],
    reset(){ this.list=[]; const {W, spacing} = metrics();
      for (let i=1;i<=4;i++) this.spawn(W + i*spacing*0.9);
    },
    spawn(x){
      const m = metrics();
      const gap = m.gap;
      const topH = rand(m.H*0.18, m.H*0.72 - gap);
      const bottomY = topH + gap;
      const w = m.clusterW;
      const debrisCountTop = 5 + Math.floor(rand(0,3));
      const debrisCountBot = 5 + Math.floor(rand(0,3));
      this.list.push({
        x, w, topH, bottomY, passed:false, rot:rand(0,Math.PI*2),
        top: makeBelt(x, 0, w, topH, debrisCountTop),
        bot: makeBelt(x, bottomY, w, m.H - bottomY, debrisCountBot),
      });
      function makeBelt(x, y, w, h, n){
        const arr=[];
        for (let i=0;i<n;i++){
          arr.push({
            // tile positions inside the belt rect
            ox: rand(0.1,0.9), oy: rand(0.1,0.9),
            s: rand(0.5, 1.2),
            fi: Math.floor(rand(0, sprites.debrisFrames.length))
          });
        }
        return {x, y, w, h, tiles:arr};
      }
    },
    update(dt){
      const m = metrics(), sp = m.scroll * (state.active ? speedMultiplier() : 0);
      for (const g of this.list) g.x -= sp * dt * 0.12;
      if (this.list.length && this.list[0].x + m.clusterW < -20) this.list.shift();
      const lastX = this.list.length ? this.list[this.list.length-1].x : -9999;
      if (lastX < m.W + m.spacing*0.1) this.spawn(m.W + m.spacing);
    },
    draw(){
      const m = metrics();
      for (const g of this.list){
        drawBelt(g.x, 0, g.w, g.topH, true, g);
        drawBelt(g.x, g.bottomY, g.w, m.H - g.bottomY, false, g);
      }
      function drawBelt(x,y,w,h,top,g){
        // Draw many rotating rock sprites packed within the belt rect
        const frameCount = sprites.debrisFrames.length;
        for (const t of (top?g.top.tiles:g.bot.tiles)){
          const fx = x + t.ox*w;
          const fy = y + t.oy*h;
          const img = sprites.debrisFrames[t.fi];
          if (!img) continue;
          const sz = Math.min(w,h)*0.35 * t.s;
          ctx.save();
          ctx.translate(fx, fy);
          ctx.rotate(((state.t*0.0009)+(t.fi*0.3)) % (Math.PI*2));
          ctx.drawImage(img, -sz/2, -sz/2, sz, sz);
          ctx.restore();
        }
        // Optional haze
        const grad = ctx.createLinearGradient(x, y, x+w, y);
        grad.addColorStop(0, 'rgba(20,24,40,0.1)'); grad.addColorStop(1, 'rgba(20,24,40,0.18)');
        ctx.fillStyle=grad; ctx.fillRect(x, y, w, h);
      }
    },
    checkScore(rx){
      for (const g of this.list){
        if (!g.passed && g.x + g.w < rx){
          g.passed = true; state.score++; scoreEl.textContent = state.score; ping();
        }
      }
    },
    collides(box){
      const m = metrics();
      for (const g of this.list){
        // use softened AABB against belts' rects
        const pad = Math.max(6, m.unit*2.2); // shrink collision zones
        const top = insetRect({x:g.x, y:0, w:g.w, h:g.topH}, pad);
        const bot = insetRect({x:g.x, y:g.bottomY, w:g.w, h:m.H - g.bottomY}, pad);
        if (rectsOverlap(box, top) || rectsOverlap(box, bot)) return true;
      }
      return false;
    }
  };
  function rectsOverlap(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
  function insetRect(r, pad){ return {x:r.x+pad, y:r.y+pad, w:Math.max(0,r.w-2*pad), h:Math.max(0,r.h-2*pad)}; }

  /* ===== Minimal SFX + Chiptune Music ===== */
  let audioCtx = null, music = null;
  function ensureAudio(){
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  function beep(freq=800, time=0.06, type='square', gain=0.02){
    if (!audioCtx || state.muted) return;
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type=type; o.frequency.value=freq; g.gain.value = gain;
    o.connect(g).connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + time);
  }
  function ping(){ beep(980, 0.07, 'square', 0.03); }
  function thump(){ beep(180, 0.12, 'sawtooth', 0.05); }

  // Tiny chiptune sequencer (two voices + drums-ish noise)
  function startMusic(){
    if (!audioCtx || state.muted) return;
    stopMusic();
    const tempo = 112; // BPM
    const spb = 60/tempo;
    const seq = [0,2,4,5,7,9,11,12]; // major-ish ladder
    const root = 392; // G4
    music = {events:[], playing:true};
    let t0 = audioCtx.currentTime + 0.05;

    function note(time, freq, dur=0.26, type='square', vol=0.02){
      const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
      o.type=type; o.frequency.value=freq; g.gain.value = 0;
      o.connect(g).connect(audioCtx.destination);
      o.start(time);
      g.gain.setTargetAtTime(vol, time, 0.01);
      g.gain.setTargetAtTime(0.0001, time + dur*0.8, 0.08);
      o.stop(time + dur + 0.1);
      music.events.push([o,g]);
    }
    function hat(time, vol=0.015){
      const b = audioCtx.createBuffer(1, 2205, audioCtx.sampleRate);
      const d = b.getChannelData(0);
      for (let i=0;i<d.length;i++) d[i] = (Math.random()*2-1) * Math.exp(-i/700);
      const s = audioCtx.createBufferSource(); s.buffer=b;
      const g = audioCtx.createGain(); g.gain.value = vol;
      const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=6000;
      s.connect(hp).connect(g).connect(audioCtx.destination);
      s.start(time);
      music.events.push([s,g,hp]);
    }
    function kick(time, vol=0.06){
      const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
      o.type='sine'; o.frequency.setValueAtTime(160, time);
      o.frequency.exponentialRampToValueAtTime(40, time + 0.18);
      g.gain.value=vol; g.gain.exponentialRampToValueAtTime(0.0001, time + 0.22);
      o.connect(g).connect(audioCtx.destination);
      o.start(time); o.stop(time + 0.25);
      music.events.push([o,g]);
    }

    // 4-bar loop
    for (let bar=0; bar<4; bar++){
      for (let step=0; step<8; step++){
        const tt = t0 + (bar*8 + step) * (spb/2);
        const n1 = root * Math.pow(2, (seq[(step+bar)%seq.length])/12);
        const n2 = root/2 * Math.pow(2, (seq[(step*2+1)%seq.length])/12);
        // melody
        if (step%2===0) note(tt, n1, 0.24, 'square', 0.018);
        // bass
        if (step%2===0) note(tt, n2, 0.28, 'triangle', 0.014);
        // drums
        hat(tt, 0.012);
        if (step%4===0) kick(tt);
      }
    }
    // schedule loop restart
    music.timer = setTimeout(()=>{ startMusic(); }, spb/2 * 32 * 1000);
  }
  function stopMusic(){
    if (!music) return;
    music.playing=false;
    if (music.timer) clearTimeout(music.timer);
    for (const ev of music.events){
      try { ev[0].stop(); } catch(e){}
    }
    music = null;
  }

  /* ===== Loop & Systems ===== */
  function beginGame(){
    if (state.started) return;
    state.started = true;
    startOverlay.style.display='none';
    ensureAudio(); // unlock on first interaction
    state.active = false; state.activeTime = 0; // wait for first tap
    reset(false);
  }
  function reset(hard){
    state.running=true; state.over=false; state.paused=false; state.t=0; state.last=performance.now(); state.score=0; state.active=false; state.activeTime=0;
    scoreEl.textContent = '0';
    if (hard) gameOverOverlay.style.display='none';
    rocket.reset(); field.reset(); bg.reset();
    rocket.vy = -metrics().maxVel*0.35;
    requestAnimationFrame(loop);
  }
  function loop(ts){
    if (!state.running) return;
    state.dt = Math.min(32, ts - state.last);
    state.last = ts;
    if (!state.paused){
      update(state.dt);
      draw();
    }
    requestAnimationFrame(loop);
  }
  function update(dt){
    state.t += dt;
    if (state.active) state.activeTime += dt;
    bg.update(dt);
    rocket.update(dt);
    field.update(dt);
    field.checkScore(rocket.x);
    if (rocket.alive && field.collides(rocket.hitbox())) rocket.crash();
    state.shake = Math.max(0, state.shake - dt*0.04);
  }
  function draw(){
    const m = metrics();
    const sx = (Math.random()*2-1)*state.shake;
    const sy = (Math.random()*2-1)*state.shake;
    ctx.save(); ctx.translate(sx, sy);
    bg.draw();
    field.draw();
    rocket.draw();
    ctx.restore();
  }

  /* Prevent pull-to-refresh overscroll */
  document.addEventListener('touchmove', function(e) {
    if (e.touches.length === 1) e.preventDefault();
  }, {passive:false});

})();
</script>
</body>
</html>
